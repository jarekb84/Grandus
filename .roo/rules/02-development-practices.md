# Change Management & Workflow

## Incremental Changes & Refactoring
- Break large refactors or features into smaller, working commits.
- Each commit should represent a complete, working vertical slice if possible.
- No "preparatory" commits that just add unused files or structure. Changes should be immediately usable.
- Prefer combining small architectural refactorings (implementing state patterns, services) with feature development rather than large-scale rewrites. (Ref: STATE_ARCHITECTURE.MD)
- When modifying a file, apply the Boy Scout rule: clean up minor issues like unnecessary comments.
- If significant structural/architectural improvements are identified that are outside the scope of the current task, flag them for potential addition to a dedicated refactoring plan (like `REFACTORING_PLAN.MD`) rather than performing them immediately.

## Commit Structure & Flow
- Identify the full scope of changes needed first.
- Break changes into logical, independent steps.
- Each step should:
    1. Be small enough to easily verify (max 3-5 files changed ideally).
    2. Result in a working application state.
    3. Not break existing functionality.
    4. Be independently reviewable.
- **Example Flow:**
    1. Start with the smallest complete unit of change (e.g., extract a component + use it, move logic + wire it, create a system + integrate it).
    2. Verify the change works completely.
    3. Commit the working change with a clear message.
    4. Move to the next logical unit and repeat.
- **Commit Messages:** Provide commit messages with a concise one-line summary followed by optional bullet points explaining the 'why' or intent behind the changes.

## Incremental Execution
- When following multi-step plans (like refactoring or implementing complex features), complete only one numbered step at a time.
- Wait for user confirmation/feedback after each step before proceeding to the next. This allows for testing and incremental commits.

## Context Management
- **Repomix:** Prefer providing full project context periodically via a `repomix-output.xml` file generated by the user, rather than relying on numerous individual file reads or searches, especially when starting new sessions or tackling large tasks.
- **Bulk File Operations:** For tasks involving numerous repetitive file operations (e.g., moving/renaming many files), consider batching them into a single PowerShell command or a temporary script, where feasible, instead of using multiple individual tool calls. Use judgment based on the number of files and complexity.

# Performance Patterns
- **Tiered Update Frequency:** Implement varying update rates for different systems within Phaser scenes (e.g., Physics @ 60fps, AI @ ~20fps, UI Sync @ ~6fps) to optimize performance. (Ref: PERFORMANCE_PLAN.MD)
- **Optimization Milestones:** Follow the defined milestones in `PERFORMANCE_PLAN.MD` for implementing optimizations like Object Pooling and Spatial Partitioning based on measured entity counts and FPS thresholds. Avoid premature optimization.

# Development Environment
- OS: Windows 10/11
- Shell: PowerShell commands preferred.
- Paths: Use backslashes (`\`) in paths for commands.
- Command Compatibility: Ensure all executed commands are Windows-compatible.

# UI/UX Principles
- **Progressive Disclosure:** Introduce UI elements and complexity gradually as mechanics are unlocked. Avoid overwhelming the player initially.