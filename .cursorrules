# Project Vision
- Incremental game focusing on visual scale and automation
- Start with manual resource gathering, evolve into automated systems
- Progressive complexity: introduce mechanics gradually
- Visual feedback is crucial - players should see their progress
- Future plans for multiplayer/cooperative gameplay

# Core Architecture Principles (SOLID)

## Single Responsibility
- Each file should have one primary purpose, one main reason to change
- Break down complex components when they handle multiple concerns
- Examples of separate concerns:
  - UI rendering
  - State management
  - Event handling
  - Data transformation
  - Business logic (Game Systems: Core game mechanics)
  - API communication
  - Game mechanics

## Open/Closed & Extension
- Design for extension without modification
- Use composition over inheritance
- Implement plugin-like architectures for game systems
- Define clear interfaces between components

# Project Structure
```typescript
src/
  app/                          # Next.js pages
  components/                   # React UI components
    common/                     # Shared components
    ui/                        # Game UI components
    game/                      # Game-specific components
      ${ComponentName}/        # Component directory
        ${ComponentName}.tsx   # Main component
        ${ComponentName}.types.ts
        components/           # Child components
        hooks/               # Component-specific hooks
  game/                       # Phaser game code
    scenes/                   # Scene definitions
    systems/                  # Game mechanics
    objects/                  # Game entities
  stores/                     # State management
    ${domain}/               # Domain-specific stores
      ${domain}Store.ts
      ${domain}Store.types.ts
```

# State Management
## State Management Guidelines
- Keep state as close as possible to where it's used
- Lift state up only when necessary
- Use context for intermediate state sharing
- Prefer composition over prop drilling
- Document state shape and mutations
- Consider using state machines for complex flows

## Global State (Zustand)
- Persistent game data (inventory, progression, settings)
- Domain-specific stores (inventory, progression, settings)
- Clear boundaries between stores

## Local State
- Component UI state only
- Temporary visual feedback
- Form inputs

## Game State
- Active session data
- Temporary run statistics
- Scene-specific state in Phaser

# Component Guidelines
- Pure presentation in React components
- Business logic in hooks or systems
- Maximum 200 lines per file
- Maximum 3 levels of JSX nesting
- Extract complex logic to dedicated files
- Use TypeScript interfaces for all props

# Naming Conventions
- PascalCase: Components, Classes, Types
- camelCase: Functions, Variables, Files
- Prefix: 'use' for hooks
- Suffix: 'Props' for prop types, 'Scene' for scenes
- No index.tsx files - explicit names only

# Development Environment
- Windows 10/11
- PowerShell commands
- Use backslashes in paths
- Commands must be Windows-compatible

# Technology Responsibilities

## Phaser (Game Engine)
- Game world elements
- Physics and collision
- Resource mechanics
- Combat systems
- Particle effects and visual feedback
- Scene management
- Asset loading

## React (UI Layer)
- User interface
- Stats display
- Menus and settings
- Configuration
- Visual feedback

# Performance Guidelines
- React.memo() for expensive renders
- Object pooling in Phaser
- Batch state updates
- Minimize React-Phaser communication
- Profile early and often 
- Keep Phaser game operations efficient
  - Use proper scene management
  - Implement object pooling for frequently created/destroyed game objects
  - Use sprite sheets and texture atlases
  - Implement proper physics group management
  - Consider using multiple scenes for different game areas